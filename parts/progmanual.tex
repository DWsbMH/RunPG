\Aref{fig_5/architektura}. ábrán látható a játék architektúrája. 
Két fő részre bontható fel, egy megjelenítő egységre és egy logikai egységre. 
A megjelenítő egység elkészítéséhez Hollósi Tamás által készített dream-iso-droid nevű keretrendszert használtam fel. 
A játékban megjelenő grafikai elemek túlnyomó részét ez kezeli. 
A logikai egység feladata a megtervezett szabályok és játékmechanikai elemek felügyelete. 
Ez az egység több kisebb modulra bontható fel, melyeknek mind megvan a saját jól elkülöníthető feladata. 
Az egység ezeket a modulokat kezeli, és a belső működésükbe nem szól bele, elfedve azokat. 
Elkerülhetetlen, hogy két modul kommunikáljon egymással, ezt is a logikai egység szabályozza. 
A két egység szoros együttműködéseként valósul meg a játék. 
A továbbiakban bemutatásra kerülnek a megvalósítás részletei. 

\Picture{A program architektúrája}{5/architektura}{width=14cm}

\subsection*{Engedélyek, rendszerkövetelmények}
\label{requirements}

Ahhoz, hogy a játék minden funkcionalitása elérhetővé váljon néhány rendszerkövetelménynek meg kell felelnie a felhasználó eszközének. 
Az eszközön legalább 4.4-es Android operációs rendszernek kell futnia, ami a 19-es API szintnek felel meg.
Ezt feltételt a \Highlight{build.gradle} fájlban adhatjuk meg, ahol más, fontos paramétereket is megadunk. 
Ebben a fájlban kell megadni többek közt, hogy mely harmadik féltől származó könyvtárakat használ az alkalmazás, és ezen könyvtárak használt verziószámát is. 

Az alkalmazásnak csupán egy engeélyre van szüksége, amit az \Highlight{AndroidManifest.xml} fájlban határozhatunk meg a következő módon:

\begin{lstlisting}
    <uses-permission android:name="android.permission.INTERNET" />
\end{lstlisting}

Ezen kívül a fájlban az alkalmazást leíró metaadatok, általános konfigurációs beállítások találhatóak, például hogy melyik legyen az induló Activity.

\section{A játék indítása}
\label{jatekinditas}

Az alkalmazás indítása után a felhasználót egy egyszerű menü fogadja a \Highlight{StartActivity} nevű osztályban. 
A menü tetején található a játék logója, melyet a játékban található több grafikai elemmel együtt Böröndi Evelin hallgatótársam készített el számomra. 
Itt két lehetőség tárul a felhasználó elé, képes csatlakozni új sport-nyomkövető szolgáltatásokhoz, vagy elkezdhet játszani. 
A csatlakoztatható szolgáltatások egy egyszerű listában tárolódnak soronként, ami tartalmazza a nevét, és egy gombot, amely elindítja a csatlakozási folyamatot. 

\subsection*{Csatlakozás nyomkövető alkalmazáshoz}
\label{trackerconnect}
Jelenleg a két legnagyobb felhasználói bázissal rendelkező sport-trackerek a Runkeeper és a Strava. 
Mindkettő rendelkezik publikusan elérhető API-val \cite{runkeeperapi} \cite{stravaapi}, mely segítségével könnyedén készíthetünk hozzájuk saját alkalmazásokat. 
Mindkét szolgáltatás esetén ahhoz, hogy a játékkal össze tudja kötni a felhasználó a sport-tracker fiókját az OAuth protokollra van szükségünk, melyet a \ref{oauth} fejezeteben mutattam be. 

A protokoll teljes működésének implementálása sok biztonsági és hibakezelési kérdést vet fel, így úgy döntöttem, hogy egy már kész könyvtárat használok hozzá. 

A választott könyvtáram a ScribeJava \cite{scribejava}, mely a protokoll több verzióját is támogatja és számos szolgáltatáshoz már kész API-val rendelkezik. 
Az általam integrált két sport-nyomkövető nem voltak elkészítve, így ezeket nekem kellett megvalósítanom. 
Szerencsére a könyvtár úgy lett kialakítva, hogy minden, a protokollt használó szolgáltatáshoz egységesen lehessen API-t készíteni. 

A Runkeeper nyomkövetőhöz elkészített API legfontosabb része a következőként néz ki:

\begin{lstlisting}
    private static final String AUTHORIZATION_URL = "https://runkeeper.com/apps/authorize?client_id=%s&response_type=code&redirect_uri=%s";
    private static final String ACCESS_TOKEN_URL = "https://runkeeper.com/apps/token";

    @Override
    public String getAccessTokenEndpoint() { return ACCESS_TOKEN_URL; }

    @Override
    public String getAuthorizationUrl(OAuthConfig config) {
        Preconditions.checkValidUrl(config.getCallback(), "Must provide a valid url as callback.");
        final StringBuilder sb = new StringBuilder(String.format(AUTHORIZATION_URL, config.getApiKey(), OAuthEncoder.encode(config.getCallback())));
        // ...
        return sb.toString();
    }
\end{lstlisting}

Mivel ez a kommunikáció hálózati tevékenységgel jár, nem történhet az Android fő programszálán. 
Egyrészt ha a fő szálon folyna ez a kommunikáció, az alkalmazás nem tudna tovább futni, amíg hitelesítési folyamat be nem fejeződik. 
Ez akár több másodpercbe is telhet a hálózati körülményeket figyelembe véve, így addig az alkalmazás blokkolódna. 
A felhasználói élmény miatt ez nem megengedhető, így ezt a folyamatot a háttérben kell elvégezni, hogy az alkalmazás zavartalanul futhasson tovább. 
Az Android SDK-ban több beépített lehetőség segítségével is meg tudjuk valósítani ezt:

\begin{itemize}
	\item Egyszerű Java szálak 
	\item AsyncTask 
	\item IntentService 
\end{itemize}

Ezeknek a lehetőségeknek megvan a maguk előnye és hátránya. 
A normál Java szálak használata széles körben elterjedt, de nagyobb, bonyolultabb programszerkezet mellett használatuk nehézkes. 
A következő választási lehetőség az Android SDk-ban bemutatott AsyncTask osztály használata. 
Ennek segítségével könnyedén indíthatunk háttérben futó kódrészleteket. 
Az osztályon belül felülírható metódusok, amelyek az adott tevékenység elején, közben, vagy a feladata végeztével hívódnak meg. 
Ez a fajta megoldás sokkal kötetlenebb, viszont ahogy az előző pontban taglalt sima szálhoz hasonlóan, ha az adott Activity, amelyikből el lett indítva háttérbe kerül, az operációs rendszer meg tudja szakítani a folyamat futását. 
Az \Highlight{IntentService} esetén ez nem történik meg, tovább egyrészt nincs \Highlight{Activity}-hez kötve, másrészt a kéréseket egy sorba teszi, amelynek a későbbieknek még fontos szerepe lesz. 

A háttérben folyó munkákért a \Highlight{FetchService} nevű osztály felelős, mely a beépített \Highlight{IntentService} osztályból származik, és felülírja az \Highlight{onHandleIntent()} metódust. 
Ez a metódus már a háttérben fut. Paraméterként egy Intent-et kap, melyet a \Highlight{FetchService} osztály statikus metódusain keresztül hozunk létre, így példányosítás nélkül is képesek vagyunk ilyen folyamatot indítani. 
Egy adott sport-trackerhez tartozó összes eddigi elmentett sportteljesítmény letöltéséhez szükséges \Highlight{Intent} elkészítése az alábbi kódrészletben látszódik. 

\begin{lstlisting}

public static void startFetchActivities(Context context, TrackerService tracker) {
	Intent intent = new Intent(context, FetchService.class);
	intent.setAction(ACTION_FETCH_ALL_ACTIVITY);
	intent.putExtra(EXTRA_TRACKER_SERVICE, tracker);
	context.startService(intent);
}

\end{lstlisting}

Ez a metódus egy sport-tracker alkalmazáshoz való sikeres csatlakozás esetén automatikus meghívódik. 
A beállított akció alapján tudjuk majd meghatározni az \Highlight{onHandleIntent()} metódusban, hogy milyen típusú műveletet kell végrehajtani. 

Mivel az itt futó kód futási ideje nemdeterminisztikus, előre nem tudhatjuk hogy mikor ér véget, hisz nagyban függ az elérhető hálózati csatlakozások jelerősségétől, így nem tudjuk mikor engedhetjük tovább a játékost a játékfelületre. 
Ahhoz, hogy valahogy tudjuk mikor ért véget az adatok letöltése, az \Highlight{IntentService} esetén rendelkezésre áll a \Highlight{BroadcastReceiver} osztály. 
Amint az összes letöltés befejeződött ezt el kell juttatnunk az \Highlight{Activity} számára, ahol a gombot megnyomtuk. 
Az üzenet létrehozása során egy új \Highlight{Intent}-et hozunk létre speciális akció típussal, amelyet broadcast üzenet formájában kiküldünk. 
Az ilyen broadcast üzenetekre feliratkozhatnak a különböző activity-k, további az is lehetséges, hogy csak bizonyos akciójú broadcast üzenetekre reagáljon, mely implementálásának főbb részlete az alábbi kódrészletben figyelhető meg:

\begin{lstlisting}
        IntentFilter mStatusIntentFilter = new IntentFilter();
        mStatusIntentFilter.addAction(FETCH_NEW_ACTIVITY_DONE);
        mStatusIntentFilter.addAction(FETCH_ALL_ACTIVITY_DONE);
        LocalBroadcastManager.getInstance(this).registerReceiver(receiver, mStatusIntentFilter);
\end{lstlisting}

Ebben az esetben regisztrálunk egy fogadó osztályt, melyet a \Highlight{BroadcastReceiver} örököltettünk és \Highlight{onReceive} metódusát felülírtuk. 
A második paramétere az az \Highlight{Intent} lesz, amelyet a háttérben futó kód befejeztével sugároztunk szét, és csak is akkor jutunk el ide, ha az adott intent objektum akciója megfelel a szűrőbe beállított akciók valamelyikének. 
Amennyiben nem csatlakozni akarunk egy lehetséges sport-trackerhez, hanem el szeretnénk kezdeni játszani, abban az esetben hasonló folyamat játszódik le, annyi eltéréssel, hogy a már csatlakoztatott trackerektől csakis a legújabb sportteljesítményeket kérjük le. 






