\Aref{fig_5/architektura}. ábrán látható a játék architektúrája. 
Két fő részre bontható fel, egy megjelenítő egységre és egy logikai egységre. 
A megjelenítő egység elkészítéséhez Hollósi Tamás által készített dream-iso-droid nevű keretrendszert használtam fel. 
A játékban megjelenő grafikai elemek túlnyomó részét ez kezeli. 
A logikai egység feladata a megtervezett szabályok és játékmechanikai elemek felügyelete. 
Ez az egység több kisebb modulra bontható fel, melyeknek mind megvan a saját jól elkülöníthető feladata. 
Az egység ezeket a modulokat kezeli, és a belső működésükbe nem szól bele, elfedve azokat. 
Elkerülhetetlen, hogy két modul kommunikáljon egymással, ezt is a logikai egység szabályozza. 
A két egység szoros együttműködéseként valósul meg a játék. 
A továbbiakban bemutatásra kerülnek a megvalósítás részletei. 

\Picture{A program architektúrája}{5/architektura}{width=14cm}

\subsection*{Engedélyek, rendszerkövetelmények}
\label{requirements}

Ahhoz, hogy a játék minden funkcionalitása elérhetővé váljon néhány rendszerkövetelménynek meg kell felelnie a felhasználó eszközének. 
Az eszközön legalább 4.4-es Android operációs rendszernek kell futnia, ami a 19-es API szintnek felel meg.
Ezt feltételt a \Highlight{build.gradle} fájlban adhatjuk meg, ahol más, fontos paramétereket is megadunk. 
Ebben a fájlban kell megadni többek közt, hogy mely harmadik féltől származó könyvtárakat használ az alkalmazás, és ezen könyvtárak használt verziószámát is. 

Az alkalmazásnak csupán egy engeélyre van szüksége, amit az \Highlight{AndroidManifest.xml} fájlban határozhatunk meg a következő módon:

\begin{lstlisting}
<uses-permission android:name="android.permission.INTERNET" />
\end{lstlisting}

Ezen kívül a fájlban az alkalmazást leíró metaadatok, általános konfigurációs beállítások találhatóak, például hogy melyik legyen az induló Activity.

\section{A játék indítása}
\label{jatekinditas}

Az alkalmazás indítása után a felhasználót egy egyszerű menü fogadja a \Highlight{StartActivity} nevű osztályban. 
A menü tetején található a játék logója, melyet a játékban található több grafikai elemmel együtt Böröndi Evelin hallgatótársam készített el számomra. 
Itt két lehetőség tárul a felhasználó elé, képes csatlakozni új sport-nyomkövető szolgáltatásokhoz, vagy elkezdhet játszani. 
A csatlakoztatható szolgáltatások egy egyszerű listában tárolódnak soronként, ami tartalmazza a nevét, és egy gombot, amely elindítja a csatlakozási folyamatot. 

\subsection*{Csatlakozás nyomkövető alkalmazáshoz}
\label{trackerconnect}
Jelenleg a két legnagyobb felhasználói bázissal rendelkező sport-trackerek a Runkeeper és a Strava. 
Mindkettő rendelkezik publikusan elérhető API-val \cite{runkeeperapi} \cite{stravaapi}, mely segítségével könnyedén készíthetünk hozzájuk saját alkalmazásokat. 
Mindkét szolgáltatás esetén ahhoz, hogy a játékkal össze tudja kötni a felhasználó a sport-tracker fiókját az OAuth protokollra van szükségünk, melyet a \ref{oauth} fejezeteben mutattam be. 

A protokoll teljes működésének implementálása sok biztonsági és hibakezelési kérdést vet fel, így úgy döntöttem, hogy egy már kész könyvtárat használok hozzá. 

A választott könyvtáram a ScribeJava \cite{scribejava}, mely a protokoll több verzióját is támogatja és számos szolgáltatáshoz már kész API-val rendelkezik. 
Az általam integrált két sport-nyomkövető nem voltak elkészítve, így ezeket nekem kellett megvalósítanom. 
Szerencsére a könyvtár úgy lett kialakítva, hogy minden, a protokollt használó szolgáltatáshoz egységesen lehessen API-t készíteni. 

A Runkeeper nyomkövetőhöz elkészített API legfontosabb része a következőként néz ki:

\begin{lstlisting}
private static final String AUTHORIZATION_URL = "https://runkeeper.com/apps/authorize?client_id=%s&response_type=code&redirect_uri=%s";
private static final String ACCESS_TOKEN_URL = "https://runkeeper.com/apps/token";

@Override
public String getAccessTokenEndpoint() { return ACCESS_TOKEN_URL; }

@Override
public String getAuthorizationUrl(OAuthConfig config) {
	Preconditions.checkValidUrl(config.getCallback(), "Must provide a valid url as callback.");
	final StringBuilder sb = new StringBuilder(String.format(AUTHORIZATION_URL, config.getApiKey(), OAuthEncoder.encode(config.getCallback())));
	// ...
	return sb.toString();
}
\end{lstlisting}

Mivel ez a kommunikáció hálózati tevékenységgel jár, nem történhet az Android fő programszálán. 
Egyrészt ha a fő szálon folyna ez a kommunikáció, az alkalmazás nem tudna tovább futni, amíg hitelesítési folyamat be nem fejeződik. 
Ez akár több másodpercbe is telhet a hálózati körülményeket figyelembe véve, így addig az alkalmazás blokkolódna. 
A felhasználói élmény miatt ez nem megengedhető, így ezt a folyamatot a háttérben kell elvégezni, hogy az alkalmazás zavartalanul futhasson tovább. 
Az Android SDK-ban több beépített lehetőség segítségével is meg tudjuk valósítani ezt:

\begin{itemize}
	\item Egyszerű Java szálak 
	\item AsyncTask 
	\item IntentService 
\end{itemize}

Ezeknek a lehetőségeknek megvan a maguk előnye és hátránya. 
A normál Java szálak használata széles körben elterjedt, de nagyobb, bonyolultabb programszerkezet mellett használatuk nehézkes. 
A következő választási lehetőség az Android SDk-ban bemutatott AsyncTask osztály használata. 
Ennek segítségével könnyedén indíthatunk háttérben futó kódrészleteket. 
Az osztályon belül felülírható metódusok, amelyek az adott tevékenység elején, közben, vagy a feladata végeztével hívódnak meg. 
Ez a fajta megoldás sokkal kötetlenebb, viszont ahogy az előző pontban taglalt sima szálhoz hasonlóan, ha az adott Activity, amelyikből el lett indítva háttérbe kerül, az operációs rendszer meg tudja szakítani a folyamat futását. 
Az \Highlight{IntentService} esetén ez nem történik meg, tovább egyrészt nincs \Highlight{Activity}-hez kötve, másrészt a kéréseket egy sorba teszi, amelynek a későbbieknek még fontos szerepe lesz. 

A háttérben folyó munkákért a \Highlight{FetchService} nevű osztály felelős, mely a beépített \Highlight{IntentService} osztályból származik, és felülírja az \Highlight{onHandleIntent()} metódust. 
Ez a metódus már a háttérben fut. Paraméterként egy Intent-et kap, melyet a \Highlight{FetchService} osztály statikus metódusain keresztül hozunk létre, így példányosítás nélkül is képesek vagyunk ilyen folyamatot indítani. 
Egy adott sport-trackerhez tartozó összes eddigi elmentett sportteljesítmény letöltéséhez szükséges \Highlight{Intent} elkészítése az alábbi kódrészletben látszódik. 

\begin{lstlisting}

public static void startFetchActivities(Context context, TrackerService tracker) {
    Intent intent = new Intent(context, FetchService.class);
    intent.setAction(ACTION_FETCH_ALL_ACTIVITY);
    intent.putExtra(EXTRA_TRACKER_SERVICE, tracker);
    context.startService(intent);
}

\end{lstlisting}

Ez a metódus egy sport-tracker alkalmazáshoz való sikeres csatlakozás esetén automatikus meghívódik, második paramétere az a TrackerService objektum, amelyhez csatlakoztunk. 
A beállított akció alapján tudjuk majd meghatározni az \Highlight{onHandleIntent()} metódusban, hogy milyen típusú műveletet kell végrehajtani. 

Mivel az itt futó kód futási ideje nemdeterminisztikus, előre nem tudhatjuk hogy mikor ér véget, hisz nagyban függ az elérhető hálózati csatlakozások jelerősségétől, így nem tudjuk mikor engedhetjük tovább a játékost a játékfelületre. 
Ahhoz, hogy valahogy tudjuk mikor ért véget az adatok letöltése, az \Highlight{IntentService} esetén rendelkezésre áll a \Highlight{BroadcastReceiver} osztály. 
Amint az összes letöltés befejeződött ezt el kell juttatnunk az \Highlight{Activity} számára, ahol a gombot megnyomtuk. 
Az üzenet létrehozása során egy új \Highlight{Intent}-et hozunk létre speciális akció típussal, amelyet broadcast üzenet formájában kiküldünk. 
Az ilyen broadcast üzenetekre feliratkozhatnak a különböző activity-k, további az is lehetséges, hogy csak bizonyos akciójú broadcast üzenetekre reagáljon, mely implementálásának főbb részlete az alábbi kódrészletben figyelhető meg:

\begin{lstlisting}
    IntentFilter mStatusIntentFilter = new IntentFilter();
    mStatusIntentFilter.addAction(FETCH_NEW_ACTIVITY_DONE);
    mStatusIntentFilter.addAction(FETCH_ALL_ACTIVITY_DONE);
    LocalBroadcastManager.getInstance(this).registerReceiver(receiver, mStatusIntentFilter);
\end{lstlisting}

Ebben az esetben regisztrálunk egy fogadó osztályt, melyet a \Highlight{BroadcastReceiver} örököltettünk és \Highlight{onReceive} metódusát felülírtuk. 
A második paramétere az az \Highlight{Intent} lesz, amelyet a háttérben futó kód befejeztével sugároztunk szét, és csak is akkor jutunk el ide, ha az adott intent objektum akciója megfelel a szűrőbe beállított akciók valamelyikének. 
Amennyiben nem csatlakozni akarunk egy lehetséges sport-trackerhez, hanem el szeretnénk kezdeni játszani, abban az esetben hasonló folyamat játszódik le, annyi eltéréssel, hogy a már csatlakoztatott trackerektől csakis a legújabb sportteljesítményeket kérjük le. 

\subsection*{Sportadatok letöltése}
\label{trackerconnect}

A különböző sportadatok letöltése olyan feladat, amely hasonlóságot és különbséget is mutat egymás között, ami az adott szolgáltatás API-jának kialakításában, és az eltárolt adatok típusában keresendő. 
A jövőben többfajta sport-tracker integrálását elősegítve kialakítottam egy felületet, ahol a szolgáltatásokhoz szükséges egyedi megoldások el vannak fedve. 
Ehhez létrehoztam egy \Highlight{IProvider} nevű interfészt, amelyben deklaráltam azokat a metódusokat, amelyek az egységes működést hivatottak megvalósítani. 
Kialakítottam továbbá egy absztrakt  \Highlight{BaseProvider} nevű osztályt, mely implementálja ezt az interfészt, valamint tartalmazza a mindenképp szükséges adatmezőket, amik minden szolgáltatás esetén azonosak. 
Mivel ez az osztály absztrakt, nem jöhet létre belőle példány, ezért nem is muszáj konkrétan megvalósítania az \Highlight{IProvider} metódusait, hanem csak a nem absztrakt gyerekeinek kell majd. 

Egy integrált sport-trackerhez el kell készíteni egy osztályt, amely ebből az osztályból öröklődik. 
A Strava-hoz elkészült osztály fontosabb elemei:

\begin{lstlisting}

@Override
public List<SportActivity> getAllActivityFromService(Context context, TrackerService tracker) { ... }

@Override
public List<SportActivity> getNewActivityFromService(Context context, TrackerService tracker) { ... }

@Override
protected SportActivity convertActivity(Object item) { ... }

@Override
public SportActivityType getUnifiedType(String typeFromTracker) { ... }

\end{lstlisting}

Mindegyik metódus az interfészben lett deklarálva, így elérve, hogy csakis az adott szolgáltatáshoz tartozó osztály legyen felelős az onnan történő adatletöltés részleteiért. 
A \Highlight{convertActivity()} metódusra azért van szükség, mert már a két integrált sport-tracker esetén is előfordult, hogy ugyanazon célt szolgáló információk nem ugyanolyan típusban tárolódnak. 
A metódus segítségével egy sporttevékenységhez tartozó adatot az alkalmazás elvárt formátumba hozható, így segítve továbbá az egységes felületet, mivel ezt a metódust az összes letöltött adatra meg kell hívni. 

\subsection*{Jutalmazás}
\label{reward}

A \ref{kovetelmenyek} fejezetben követelményként lett lefektetve, hogy a játékos a valós sportteljesítménye alapján jutalmakat kaphasson, amit a játékban felhasználhat. 
Miután az adatok letöltése megtörtént és a kívánt formátumba kerültek, megkezdődhet a vizsgálat, hogy az újonnan letöltött adatokért jár-e a felhasználó számára ajándék. 
A \Highlight{Requirements} osztály tudja megvizsgálni, hogy az adott sportolásért járhat-e ajándék. 
Ennek egyetlen statikus metódusa van, amely igazzal tér vissza, ha megfelelt az elvárásoknak, hamissal, ha pedig nem érte el a minimum megszabott követelményeket. 
A jutalom kisorsolására létrehoztam a \Highlight{RewardDrawer} osztályt, és minden új adatot megvizsgál. 
A jutalmazás függ a sportolás típusától, hosszától, esetleges egyéb paramétereitől is, maga a jutalom is többféle lehet, ugyanakkor minden esetben mindenféle feltétel nélkül kiszámolásra kerül az adott sportteljesítmény alapján egy staminamennyiség, amit a játékos megkap. 

A kiosztható jutalmak a következőek:

\begin{itemize}
	\item Arany
	\item Fegyver 
	\item Varázsital 
\end{itemize}

Továbbá elkészült három csoport, amelyekbe besorolásra kerültek a leggyakrabban előforduló sporttípusok. 
Az előbb felsorolt jutalmak a három csoport esetén más-más eséllyel adományozható. 
A kialakított csoportok és a hozzájuk tartozó esélyeket az \ref{fig_5/jutalom}. ábrán látható táblázatban nézhetjük meg. 

\Picture{Jutalomcsoportok és esélyek táblázata}{5/jutalom}{width=14cm}

\section{Adatbázis felépítése}
\label{database}

Minden Androidos alkalmazás rendelkezhet egy helyi SQLite adatbázissal, amelybe tárolhatja azokat az adatokat amelyeket két indítás között is meg akarunk őrizni az alkalmazásban. 
Az SQLite egy több platformra fejlesztett, kisméretű relációs adatbázis-kezelő rendszer, mely tökéletesen illik a felhasználó okos-eszközének véges erőforrásaihoz. 
Az adatbázissal való kommunikáció SQL utasításokkal történhet, amely nagyobb alkalmazások esetén nagyban megnövelheti a kódbázis méretét és potenciális hibákhoz vezethet. 
Ezt elkerülendő az felhasználtam az ORMLite könyvtárat, amelyet részletesebben bemutattam a \ref{ormlite} alfejezetben. 

A könyvtár használatához el kell készítenünk egy olyan osztályt, amelyen keresztül végre tudunk hajtani különböző akciókat az adatbázissal. 
Ehhez örököltetni kell a könyvtárban található \Highlight{OrmLiteSqliteOpenHelper} osztályból és felül kell írni az \Highlight{onCreate()} és \Highlight{onUpgrade()} metódusokat.
Az \Highlight{onCreate()} metódus az első adatbázis-elérés alkalmával fut le, az alkalmazás futása során egyetlen egyszer, így itt kell létrehozni az adattáblákat és esetleges kezdeti értékekkel feltölteni. 
Az \Highlight{onUpgrade()} metódus akkor hívódik meg, ha az alkalmazás egy újabb verziója telepítődik az eszközre, így ha valami struktúrális változás történt az adatbázis szerkezetében a legutóbbi verzió óta, itt lehet a megfelelő lépéseket megtenni a kompatibilitás megőrzése érdekében. 

Az elkészült adatbázis fontosabb adattáblái és azok kapcsolata az \ref{fig_5/adatbazis}. ábrán látható. 

\Picture{Az adatbázis szerkezete}{5/adatbazis}{width=14cm}

Egy adattábla elkészítéséhez elegendő egy egyszerű Java osztályt létrehozni, és ellátni a megfelelő annotációkkal, erről egy egyszerű példa az alábbiakban látható:

\begin{lstlisting}
@DatabaseTable(tableName = "player")
public class Player implements CreatureData {

    @DatabaseField(columnName = "id", generatedId = true)
    private int id;

    @DatabaseField(columnName = "player_gold", defaultValue = "0")
    private int gold;

    @DatabaseField(foreign = true, foreignAutoRefresh = true)
    private Attributes attributes;

    @ForeignCollectionField(eager = true)
    private ForeignCollection<SportActivity> sportActivities;

    // ...
}
\end{lstlisting}

Az osztály tetején elhelyezett \Highlight{@DatabaseTable} annotációval lehet megadni, hogy a hozzá tartozó adatbázistáblát milyen néven hozza létre az OrmLite. 
Miden olyan osztálynak rendelkezni kell egyedi azonosító attribútummal, amit szintén annotáció segítségével lehet megadni. 
Képes a mező neve alapján automatikusan oszlopnevet generálni, de lehetőség van egyedileg is megadni azt. 
Amennyiben nem használnánk semmilyen keretrendszert az adatbázis felett, akkor nekünk kéne gondoskodni, hogy az idegen kulcsokat rendben vissza legyenek fejtve objektumokká, ezt a terhet leveszi rólunk a könyvtár. 

Miután elkészült az összes entitás, mindegyikhez létre kell hozni egy DAO objektumot, amely segítségével képesek leszünk az adott entitást kezelni az adatbázisban. 
Az \Highlight{IManager} interfész tartalmazza azokat a metódusokat, amelyek segítenek egy egységes felület kialakításában. 
A technikai részletek elfedése érdekében létrehoztam egy absztrakt \Highlight{DataManager} osztály amely implementálja ezt az interfészt. 
Ez az osztály továbbá tartalmaz egy objektumot a korábban említett \Highlight{@OrmLiteSqliteOpenHelper}-ből származtatott osztályból, és az adott entitáshoz tartozó DAO-ból.
A gyerekosztályok implementálása után ugyanazon felületet használva tudunk a megfelelő adatbázis-táblával kommunikálni. 

\section{Játék megjelenítése}
\label{megjelenites}

A játékban megjelenő grafikai elemekért a \ref{jatekmotor} alfejezetben megvitatott indokok alapján választott dream-iso-droid játékmotor a felelős. 
Az alkalmazás indulása és az esetleges új sportadatok letöltése után a felhasználói interakcióra betöltődik a játék fő grafikus felülete. 
A korábbiakkal ellentétben, ahol is natív Androidos grafikai felületekkel találkozhattunk, az itt található legtöbb elemet a játékmotor rendereli le. 
Ez a felület egy új \Highlight{Activity}-ből származtatott gyerekosztályban található, aminek a neve \Highlight{GameActivity}. 
Az osztályhoz tartozik egy xml leíró fájl, amiben megadhatjuk, hogy az Activity által megjelenített vizuális elemeknek milyen szerkezete van. 
A legfőbb adatok a fájlban található elemekről az alább tekinthető meg:

\begin{lstlisting}
<RelativeLayout>
    <com.diploma.lilian.engine.GLCanvas android:id="@+id/glcanvas" />

    <FrameLayout android:id="@+id/hud_container" />

    <ImageButton android:id="@+id/inventory_open" />
</RelativeLayout>
\end{lstlisting}

A \Highlight{RelativeLayout} tulajdonsága miatt az egymás után következő elemek, ha nincs meghatározva pozíciójuk, a előttük lévő elem fölé kerülnek. 
Ezt kihasználva a legelső elem a játékmotorban megtalálható úgynevezett vászon, a \Highlight{GLCanvas} osztály mely minden megjelenítendő vizuális elemet itt rajzol ki. 
Efölött található egy hud\_container nevű elem, amely teljes egészében a vászon fölé terül, feladata hogy megjelenítse a játékoshoz kapcsolódó legfontosabb információkat.

A vászonra a játékmotor mindig a beállított \Highlight{GameScene} osztály által szolgáltatott képkockákat rajzolja ki. 
Ez szintén a játékmotorban található, az osztály maga absztrakt, így önmagában nem, csakis örököltetett gyerekei képesek tartalmukat megjeleníteni a vásznon. 
Az elkészült játék három fő jelenetre bontható, amelyek a következőek:

\begin{itemize}
	\item Városi jelenet 
	\item Harctér jelenet 
	\item Harci jelenet 
\end{itemize}

A három jelenetnek jól elhatárolt feladatköre van és más-más grafikai elemek tárolására szolgálnak, ugyanakkor rendelkeznek olyan tulajdonságokkal is, amik mindhárom esetén megegyeznek. 
Ennek érdekében létrehoztam egy absztrakt osztályt \Highlight{BaseScene} néven a \Highlight{GameScene} osztályból örököltetve, melyben ezen közös funkcionalitásokat valósítottam meg, így az egyes jeleneteknél ezeket nem kellett redundáns módon megvalósítani. 
Minden gyerekosztályban rendelkezik az örököltetés révén egy \Highlight{init()} metódussal, amelyben az úgynevezett sprite-ok inicializálása történik. 
Ezen sprite-ok tulajdonképpen kétdimenziós képek, így a vásznon csupán ezen képek sokasága látszódik, és folyamatos váltakozása kelti az animáció képzetét. 

Ebben az esetben is ugyanazon funkciót kell megvalósítania jelenetfüggően, így itt is elkészítettem egy \Highlight{ISpriteProvider} nevű interfészt, amelyben definiálásra kerültek azok amelyek segítségével ez a folyamat egységesen végrehajtható minden jelenetben. 
Elkészült egy \Highlight{BaseSpriteProvider} nevű absztrakt osztály, ami megvalósítja ezen interfész metódusait, továbbá tartalmazza a beolvasásához szükséges adattagokat. 
Egy jelenet példányosítása során beállítjuk a hozzá tartozó \Highlight{ISpriteProvider}-t implementáló objektumot. 
Amikor egy adott jelenet \Highlight{init()} metódusa lefut, az interfészen keresztül el tudjuk készíteni a jelenethez szükséges sprite-okat, és ezeket a játékmotor már a vászonra tud rajzolni. 
A sprite-ok különböző adatait, amiket az \Highlight{assets} könyvtárban tárolt xml fájlokból olvasunk be, az engine-ben található \Highlight{IsoSprite} osztályban tároljuk. 
A fájlban található animation tag-ekkel lehet megadni, hogy az adott sprite milyen animációk végrehajtására képes. 
A frame tag-ek között megadjuk, hogy a forráskép milyen pixeltartománya tartalmazza azt a területet, amelyet a játékmotornak meg kell jeleníteni az animáció futása során. 
Egy ilyen xml fájl szerkezete az alábbi kódrészletben látható, a hozzá tartozó kép pedig az \ref{fig_5/sprite}. ábrán látható:

\begin{lstlisting}
<isosprite name="male_light_sprite"	imgname="player_set">
	<animations imgwidth="384" imgheight="384">
		<animation name="up_move" steptime="150" startframe="0">
			<frame left="0" right="32" top="144" bottom="192"/>
			<frame left="32" right="64" top="144" bottom="192"/>
			<frame left="64" right="96" top="144" bottom="192"/>
		</animation>
	</animations>
	...
</isosprite>

\end{lstlisting}

\Picture{A játékoshoz tartozó forráskép}{5/sprite}{width=3cm}















